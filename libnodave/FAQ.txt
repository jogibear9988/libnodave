Questions I have been asked and answers:

Q: My VB,.NET or Delphi application doesn't work. I suppose libnodave doesn't work with my 
   hardware or doesn't work at all. Can you help me?
A: You can most easily find out whether Libnodave works with your hardware, PLC, adapter
   etc: try the precompiled test programs. If they don't work (trying different options when
   suggested), it's clearly libnodave's fault.
   If they work, it's your application (or there is a little chance, the problem is in the 
   interface to the language you use).

Q: Can you help me?
A: Before asking me, try out the test programs as described above. When they don't work for
   you, send me the output with debug option, e.g. do:
   testMPI -d COM1 >debugout.txt
   If they work, but your application doesn't, do:
   Insert "daveSetDebug(daveDebugAll)" before calling anything else from libnodave.
   Then do:
   yourappliation >debugout.txt
   For those people who grew up with mice and don't know the command line:
   This works even with MS-Excel. Create a spreadsheet, import the VBA module, 
   - uncomment the "call daveSetDebug(daveDebugAll)" at the begin of sub initialize,
   - save the sheet.
   - then, from commandline (dos box, cmd) do:
	excel testsheet >debugout.txt 
   All debug output (otherwise invisible) goes into debugout.txt.
   When time falls short, I shall discard mails not containig debug output!

Q: What mail format do you prefer?
A: Ok, nobody asked that, but I DO prefer PLAIN TEXT.

Q: I want to read out whether my PLC is in RUN or STOP mode. Is there a function for that?
A: No, not a specialized one. For S7-300/400, use daveReadSZL to read the diagnostic lists. 
   This is what Step7 does. You will find information about IDs and indices in Siemens 
   documentation. The state of all the CPU LEDs is in ID 25 (19hex) index 0.
   With S7-200, the information is somewhere in the system data.

Q: I trying to trace libnodave with a debugger. I need help?
A: There is no reason to use a debugger on libnodave unless you suspect one of the
   following things:
   - memory leaks
   - range overflows, on number or array indices
   - problems with passing parameters to library functions
   In the latter case, better recompile libnodave after uncommenting #define DEBUG_CALLS in
   nodave.c.
   To find problems with PLCs and adapters, the FAR better way is to use 
   setDaveDebug(daveDebugAll). This will show you what is sent and received from PLC/adapter
   and it will show you the relevant information instead of extracting it from memory
   contents or processor registers. 

Q: Can you give documentation about S7 communication or MPI protocol?
A: No, I can't. What I know about it is from reverse engineering. This means sniffing lots of 
   packets, trying to make sense of them and trying to generate them with my own code.
   If things are named so or so in libnodave this reflects my current hypothesis. I could 
   try to write documentation, but that would allways be a step behind the code: The code
   is what can be proven against existing hardware, i.e. reaity. The docs cannot. And I think 
   the code is fairly well documented... 

Q: So why do you have these complicated structures?
A: What people might have found complicated are probably the pointers to protocol dependent
   functions. In fact, they make the library more simple in two ways:
   - First, they separate packet forming from transport. If someone finds out how to do some
     function that can be done with a Simatic S7, it is sufficient to implement the packet
     forming part and it will most likely work with any transport protocol. Vice versa, if there
     would be a new transport mechanism, probaly all functions will work with it as soon as the
     transport functions are implemented. Version 0.8 clearly shows that by implementing a 
     transport vie s7online.dll.
   - Commercial libraries I looked at usually have separate sets of functions for the 200 
     and the 300/400 family. Libnodave hasn't, so you have less to learn about the API while your
     code can do more without any modification.


Q: So why do you have these complicated structures?
A: What people might have found complicated are probably the pointers to protocol dependent
   functions. In fact, they make the library more simple in two ways:
   - First, they separate packet forming from transport. If someone finds out how to do some
     function that can be done with a Simatic S7, it is sufficient to implement the packet
     forming part and it will most likely work with any transport protocol. Vice versa, if there
     would be a new transport mechanism, probaly all functions will work with it as soon as the
     transport functions are implemented. Version 0.8 clearly shows that by implementing a 
     transport vie s7online.dll.
   - Commercial libraries I looked at usually have separate sets of functions for the 200 
     and the 300/400 family. Libnodave hasn't, so you have less to learn about the API while your
     code can do more without any modification.
   
Q: Why do you export these structures if you say they are meaningless for applications?     
A: They are not completely meaningless. There are also a lot of "intermediate step functions"
   that are exported from the .dll or.so which are normally of no use to end users.
   - All this is there - in the spirit of open source - for those who want to do their
     own experiments. It may give you possibilities I did not think of.
   - At least once, I could help a user implementing a new function (daveForce200). He only
     had to add about 20 lines to his application which in turn called intermediate steps
     of packet forming and analysis, like _daveAddData.

Q: Why aren't there functions like readOutputs, readInputs, readData ?     
   - Other libraries usually have separate functions to read from inputs, outputs, flags,
     data blocks and so on. Libnodave hasn't. Again, you have to learn less about the API.
Q: Why aren't there functions like readBytes, readIntegers, readDWords, readFloat ?     
   - Other libraries often have separate functions to read integers, dwords or floats.
     Libnodave hasn't. The reason is: If you have a DB (or memory area) containg mixed data 
     types, with those function you can only read parts of such a block. Or you use readBytes
     to read the memory as raw bytes and you are left alone wit the conversion.
     Libnodave generally reads an entire block of data as bytes and then provides you 
     with conversion functions to convert it to PLC data types and byte order.
       
       
